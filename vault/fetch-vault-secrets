#!/bin/bash
set -euo pipefail

# -----------------------------
# Defaults / Configuration
# -----------------------------
DEFAULT_VAULT_BASE_URL=""
DEFAULT_VAULT_ORG="faithlink"
DEFAULT_OUTPUT_FILE=".env"

VAULT_BASE_URL="${VAULT_BASE_URL:-$DEFAULT_VAULT_BASE_URL}"
VAULT_ORG="${VAULT_ORG:-$DEFAULT_VAULT_ORG}"
VAULT_TOKEN="${VAULT_TOKEN:-}"  # no default, must be provided
OUTPUT_FILE="${OUTPUT_FILE:-$DEFAULT_OUTPUT_FILE}"
REPO=""
OMIT_KEYS=()

# -----------------------------
# Helper function to print errors
# -----------------------------
fatal() {
  echo "Error: $*" >&2
  exit 1
}

# -----------------------------
# Usage function
# -----------------------------
usage() {
  echo "Usage: $0 -t <vault_token> -r <repo> [-o <key1,key2,...>] [-e <output_file>] [-g <org>] [-u <vault_base_url>]" >&2
  echo
  echo "Options:"
  echo "  -t   Vault token (or set VAULT_TOKEN env variable)"
  echo "  -r   Vault repo name (required)"
  echo "  -o   Comma-separated list of keys to omit"
  echo "  -e   Output .env file (default: $DEFAULT_OUTPUT_FILE)"
  echo "  -g   Vault org (optional, fallback: VAULT_ORG env or default '$DEFAULT_VAULT_ORG')"
  echo "  -u   Vault base URL (optional, fallback: VAULT_BASE_URL env or default '$DEFAULT_VAULT_BASE_URL')"
  exit 1
}

# -----------------------------
# Parse command line arguments
# -----------------------------
parse_args() {
  while getopts "t:r:o:e:g:u:" opt; do
    case $opt in
      t) VAULT_TOKEN="$OPTARG" ;;
      r) REPO="$OPTARG" ;;
      o) IFS=',' read -r -a OMIT_KEYS <<< "$OPTARG" ;;
      e) OUTPUT_FILE="$OPTARG" ;;
      g) VAULT_ORG="$OPTARG" ;;
      u) VAULT_BASE_URL="$OPTARG" ;;
      *) usage ;;
    esac
  done

  # Check required args
  if [[ -z "$VAULT_TOKEN" ]] || [[ -z "$REPO" ]]; then
    usage
  fi
}

# -----------------------------
# Build Vault path
# -----------------------------
vault_path() {
  echo "v1/$VAULT_ORG/data/$REPO"
}

# -----------------------------
# Fetch secrets from Vault
# -----------------------------
fetch_secrets() {
  local path="$1"
  echo "Fetching $path from $VAULT_BASE_URL..." >&2
  response=$(curl -s -f -H "Authorization: Bearer $VAULT_TOKEN" \
    -H "Content-Type: application/json" \
    "$VAULT_BASE_URL/$path") || fatal "Failed to fetch secrets from $path"

  echo "$response" | jq -r '.data.data | to_entries[] | "\(.key)=\"\(.value)\""' \
    || fatal "Failed to parse secrets JSON from $path"
}

# -----------------------------
# Remove omitted keys from a file
# -----------------------------
remove_omitted_keys() {
  local file="$1"
  for key in "${OMIT_KEYS[@]}"; do
    sed -i "/^$key=/d" "$file" || fatal "Failed to remove key '$key' from temp file"
  done
}

# -----------------------------
# Merge fetched secrets with existing output file
# -----------------------------
merge_output_file() {
  local temp_file="$1"

  # Backup existing output file
  if [[ -f "$OUTPUT_FILE" ]]; then
    cp "$OUTPUT_FILE" "$OUTPUT_FILE.bak.$(date +%Y%m%d%H%M%S)" \
      || fatal "Failed to backup existing $OUTPUT_FILE"
    echo "Backup of existing $OUTPUT_FILE created."
  fi

  if [[ -f "$OUTPUT_FILE" ]]; then
    cat "$OUTPUT_FILE" >> "$temp_file" || fatal "Failed to append existing $OUTPUT_FILE to temp file"
  fi

  awk -F= '!seen[$1]++' "$temp_file" | tac | awk -F= '!seen[$1]++' | tac > "$OUTPUT_FILE" \
    || fatal "Failed to merge secrets into $OUTPUT_FILE"
}

# -----------------------------
# Main function
# -----------------------------
main() {
  parse_args "$@"
  TEMP_FILE=$(mktemp)

  PATH_TO_FETCH=$(vault_path)
  fetch_secrets "$PATH_TO_FETCH" >> "$TEMP_FILE"

  if [[ ${#OMIT_KEYS[@]} -gt 0 ]]; then
    remove_omitted_keys "$TEMP_FILE"
  fi

  merge_output_file "$TEMP_FILE"

  rm "$TEMP_FILE"
  echo "All secrets written/merged into $OUTPUT_FILE"
}

# Run main
main "$@"
