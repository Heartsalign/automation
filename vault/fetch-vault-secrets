#!/bin/bash
set -euo pipefail

# -----------------------------
# Defaults / Configuration
# -----------------------------
DEFAULT_VAULT_BASE_URL=""
DEFAULT_VAULT_ORG="faithlink"
DEFAULT_OUTPUT_FILE=".env"

VAULT_BASE_URL="${VAULT_BASE_URL:-$DEFAULT_VAULT_BASE_URL}"
VAULT_ORG="${VAULT_ORG:-$DEFAULT_VAULT_ORG}"
VAULT_TOKEN="${VAULT_TOKEN:-}"  # no default, must be provided
OUTPUT_FILE="${OUTPUT_FILE:-$DEFAULT_OUTPUT_FILE}"
REPOS=()

# -----------------------------
# Helper function to print errors
# -----------------------------
fatal() {
  echo "Error: $*" >&2
  exit 1
}

# -----------------------------
# Usage function
# -----------------------------
usage() {
  echo "Usage: $0 -t <vault_token> -r <repo1,repo2,...> [-e <output_file>] [-g <org>] [-u <vault_base_url>]" >&2
  echo
  echo "Options:"
  echo "  -t   Vault token (or set VAULT_TOKEN env variable)"
  echo "  -r   Vault repo names (comma-separated, required)"
  echo "  -e   Output .env file (default: $DEFAULT_OUTPUT_FILE)"
  echo "  -g   Vault org (optional, fallback: VAULT_ORG env or default '$DEFAULT_VAULT_ORG')"
  echo "  -u   Vault base URL (optional, fallback: VAULT_BASE_URL env or default)"
  exit 1
}

# -----------------------------
# Parse command line arguments
# -----------------------------
parse_args() {
  while getopts "t:r:e:g:u:" opt; do
    case $opt in
      t) VAULT_TOKEN="$OPTARG" ;;
      r) IFS=',' read -r -a REPOS <<< "$OPTARG" ;;
      e) OUTPUT_FILE="$OPTARG" ;;
      g) VAULT_ORG="$OPTARG" ;;
      u) VAULT_BASE_URL="$OPTARG" ;;
      *) usage ;;
    esac
  done

  # Check required args
  if [[ -z "$VAULT_TOKEN" ]] || [[ ${#REPOS[@]} -eq 0 ]]; then
    usage
  fi
}

# -----------------------------
# Build Vault path for a repo
# -----------------------------
vault_path() {
  local repo="$1"
  echo "v1/$VAULT_ORG/data/$repo"
}

# -----------------------------
# Fetch secrets from Vault
# -----------------------------
fetch_secrets() {
  local path="$1"
  echo "Fetching $path from $VAULT_BASE_URL..." >&2
  response=$(curl -s -f -H "Authorization: Bearer $VAULT_TOKEN" \
    -H "Content-Type: application/json" \
    "$VAULT_BASE_URL/$path") || fatal "Failed to fetch secrets from $path"

  # Convert JSON to key="value" pairs
  echo "$response" | jq -r '.data.data | to_entries[] | "\(.key)=\"\(.value)\""' \
    || fatal "Failed to parse secrets JSON from $path"
}

# -----------------------------
# Merge fetched secrets with existing output file
# -----------------------------
merge_output_file() {
  local temp_file="$1"

  # Backup existing output file
  if [[ -f "$OUTPUT_FILE" ]]; then
    cp "$OUTPUT_FILE" "$OUTPUT_FILE.bak.$(date +%Y%m%d%H%M%S)" \
      || fatal "Failed to backup existing $OUTPUT_FILE"
    echo "Backup of existing $OUTPUT_FILE created." >&2
  fi

  if [[ -f "$OUTPUT_FILE" ]]; then
    cat "$OUTPUT_FILE" >> "$temp_file" || fatal "Failed to append existing $OUTPUT_FILE to temp file"
  fi

  awk -F= '!seen[$1]++' "$temp_file" | tac | awk -F= '!seen[$1]++' | tac > "$OUTPUT_FILE" \
    || fatal "Failed to merge secrets into $OUTPUT_FILE"
}

# -----------------------------
# Main function
# -----------------------------
main() {
  parse_args "$@"
  TEMP_FILE=$(mktemp)

  for repo in "${REPOS[@]}"; do
    PATH_TO_FETCH=$(vault_path "$repo")
    fetch_secrets "$PATH_TO_FETCH" >> "$TEMP_FILE"
  done

  merge_output_file "$TEMP_FILE"

  rm "$TEMP_FILE"
  echo "All secrets written/merged into $OUTPUT_FILE" >&2
}

# Run main
main "$@"
